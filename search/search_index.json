{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p><code>ipybox</code> is a lightweight, stateful and secure Python code execution sandbox built with IPython and Docker. Designed for AI agents that interact with their environment through code execution, it is also well-suited for general-purpose code execution. Fully open-source and free to use, ipybox is distributed under the Apache 2.0 license.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Secure Execution: Executes code in isolated Docker containers, preventing unauthorized access to the host system.</li> <li>Stateful Execution: Retains variable and session state across commands using IPython kernels.</li> <li>Real-Time Output Streaming: Streams execution outputs directly, enabling real-time feedback.</li> <li>Enhanced Plotting Support: Facilitates downloading plots created with Matplotlib and other libraries.</li> <li>Flexible Dependency Management: Supports installing and updating dependencies during runtime or at build time.</li> <li>Resource Management: Manages container lifecycle with built-in timeout and resource control mechanisms.</li> <li>Reproducible Environments: Provides a consistent execution setup across different systems to ensure reproducibility.</li> </ul>"},{"location":"#status","title":"Status","text":"<p><code>ipybox</code> is in an early stage of development, with ongoing refinements and enhancements to its core features. Community feedback and contributions are greatly appreciated as <code>ipybox</code> continues to evolve.</p>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install ipybox\n</code></pre>"},{"location":"installation/#docker-image","title":"Docker image","text":"<p>Before you can use <code>ipybox</code>, you need to build a Docker image. This image contains the required dependencies for executing Python code in stateful and isolated sessions.</p> <p>Note</p> <p>Building an <code>ipybox</code> Docker image requires Docker to be installed on your system. Containers created from that image will run with the same user and group IDs as the user who built the image, ensuring proper file permissions on mounted host directories.</p>"},{"location":"installation/#default-build","title":"Default build","text":"<p>To build an <code>ipybox</code> Docker image with default settings and no extra dependencies:</p> <pre><code>python -m ipybox build\n</code></pre> <p>This creates a Docker image tagged as <code>gradion-ai/ipybox</code> with base Python dependencies required for the code execution environment.</p>"},{"location":"installation/#custom-build","title":"Custom build","text":"<p>To create a custom <code>ipybox</code> Docker image with additional dependencies for your application, create a dependencies file (e.g., <code>dependencies.txt</code>) following. For example:</p> dependencies.txt<pre><code>pandas = \"^2.2\"\nscikit-learn = \"^1.5\"\nmatplotlib = \"^3.9\"\n</code></pre> <p>To build an image with custom tag and dependencies:</p> <pre><code>python -m ipybox build -t my-box:v1 -d path/to/dependencies.txt\n</code></pre> <p>The dependencies file should list Python packages in Poetry dependency specification format. These will be installed in addition to the base dependencies required for the execution environment. The execution container also supports installing dependencies at runtime.</p>"},{"location":"usage/","title":"Usage","text":"<p>The two main classes of the <code>ipybox</code> package are <code>ExecutionContainer</code> and <code>ExecutionClient</code>.</p> <p>Note</p> <p>Runnable scripts of the source code on this page are available in the examples directory.</p>"},{"location":"usage/#basic-usage","title":"Basic usage","text":"<p>For executing code in <code>ipybox</code> you first need to create a Docker container from an <code>ipybox</code> Docker image and then an IPython kernel running in that container. This is done with the <code>ExecutionContainer</code> and the <code>ExecutionClient</code> context managers.</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:  # (1)!\n    async with ExecutionClient(port=container.port) as client:  # (2)!\n        result = await client.execute(\"print('Hello, world!')\")  # (3)!\n        print(f\"Output: {result.text}\")  # (4)!\n</code></pre> <ol> <li>Create and start a container for code execution</li> <li>Create and connect to an IPython kernel</li> <li>Execute Python code and await the result</li> <li>Output: <code>Hello, world!</code></li> </ol> <p>The default image used by <code>ExecutionContainer</code> is <code>gradion-ai/ipybox</code>. You can specify a custom image with the <code>tag</code> argument like in <code>ExecutionContainer(tag=\"my-box:v1\")</code>, for example.</p> <p>Note</p> <p>Instead of letting the <code>ExecutionContainer</code> context manager handle the lifecycle of the container, you can also manually run and kill the container.</p>"},{"location":"usage/#state-management","title":"State management","text":"<p>Code execution within the same <code>client</code> context is stateful i.e. you can reference variables from previous executions. Code executions in different client contexts are isolated from each other:</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.port) as client_1:  # (1)!\n        result = await client_1.execute(\"x = 1\")  # (2)!\n        assert result.text is None\n        result = await client_1.execute(\"print(x)\")  # (3)!\n        assert result.text == \"1\"\n\n    async with ExecutionClient(port=container.port) as client_2:  # (4)!\n        try:\n            await client_2.execute(\"print(x)\")  # (5)!\n        except ExecutionError as e:\n            assert e.args[0] == \"NameError: name 'x' is not defined\"\n</code></pre> <ol> <li>First client context</li> <li>Execute code that defines variable x</li> <li>Reference variable x defined in previous execution</li> <li>Second client context</li> <li>Variable x is not defined in <code>client_2</code> context</li> </ol>"},{"location":"usage/#output-streaming","title":"Output streaming","text":"<p>The <code>ExecutionClient</code> supports streaming output as it's generated during code execution:</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.port) as client:\n        code = \"\"\"\n        import time\n        for i in range(5):\n            print(f\"Processing step {i}\")\n            time.sleep(1)\n        \"\"\"  # (1)!\n\n        execution = await client.submit(code)  # (2)!\n        print(\"Streaming output:\")\n        async for chunk in execution.stream():  # (3)!\n            print(f\"Received output: {chunk.strip()}\")  # (4)!\n\n        result = await execution.result()  # (5)!\n        print(\"\\nAggregated output:\")\n        print(result.text)  # (6)!\n</code></pre> <ol> <li>Code that produces gradual output</li> <li>Submit the code for execution</li> <li>Stream the output</li> <li>Prints one line per second:     <pre><code>Received output: Processing step 0\nReceived output: Processing step 1\nReceived output: Processing step 2\nReceived output: Processing step 3\nReceived output: Processing step 4\n</code></pre></li> <li>Get the aggregated output as a single result</li> <li>Prints the aggregated output:     <pre><code>Aggregated output:\nProcessing step 0\nProcessing step 1\nProcessing step 2\nProcessing step 3\nProcessing step 4\n</code></pre></li> </ol> <p>The <code>stream()</code> method accepts an optional <code>timeout</code> argument (defaults to <code>120</code> seconds). In case of timeout, the execution is automatically terminated by interrupting the kernel.</p>"},{"location":"usage/#installing-dependencies-at-runtime","title":"Installing dependencies at runtime","text":"<pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.port) as client:\n        execution = await client.submit(\"!pip install einops\")  # (1)!\n        async for chunk in execution.stream():  # (2)!\n            print(chunk, end=\"\", flush=True)\n\n        result = await client.execute(\"\"\"\n            import einops\n            print(einops.__version__)\n        \"\"\")  # (3)!\n        print(f\"Output: {result.text}\")  # (4)!\n</code></pre> <ol> <li>Install the <code>einops</code> package using pip</li> <li>Stream the installation progress. Something like     <pre><code>Collecting einops\nDownloading einops-0.8.0-py3-none-any.whl (10.0 kB)\nInstalling collected packages: einops\nSuccessfully installed einops-0.8.0\n</code></pre></li> <li>Import and use the installed package</li> <li>Prints <code>Output: 0.8.0</code></li> </ol> <p>You can also install and use a package within a single execution. There's no need to have two separate executions as done in the example above.</p>"},{"location":"usage/#creating-and-returning-plots","title":"Creating and returning plots","text":"<p>Plots created with <code>matplotlib</code> or other libraries are returned as PIL images. Images are not part of the output stream, but are available as <code>images</code> list in the <code>result</code> object.</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.port) as client:\n        execution = await client.submit(\"\"\"\n            !pip install matplotlib\n\n            import matplotlib.pyplot as plt\n            import numpy as np\n\n            x = np.linspace(0, 10, 100)\n            plt.figure(figsize=(8, 6))\n            plt.plot(x, np.sin(x))\n            plt.title('Sine Wave')\n            plt.show()\n\n            print(\"Plot generation complete!\")\n            \"\"\")  # (1)!\n\n        async for chunk in execution.stream():  # (2)!\n            print(chunk, end=\"\", flush=True)\n\n        result = await execution.result()\n        result.images[0].save(\"sine.png\")  # (3)!\n</code></pre> <ol> <li>Install <code>matplotlib</code> and generate a plot</li> <li>Stream output text (installation progress and <code>print</code> statement)</li> <li>Get attached image from execution result and save it as sine.png</li> </ol>"},{"location":"usage/#bind-mounts","title":"Bind mounts","text":"<p>Bind mounts allow executed code to read and write files on the host machine.</p> <pre><code>await aiofiles.os.makedirs(\"data\", exist_ok=True)\nawait aiofiles.os.makedirs(\"output\", exist_ok=True)\n\nbinds = {  # (1)!\n    \"./data\": \"data\",  # (2)!\n    \"./output\": \"output\",  # (3)!\n}\n\nasync with aiofiles.open(\"data/input.txt\", \"w\") as f:\n    await f.write(\"hello world\")\n\nasync with ExecutionContainer(binds=binds) as container:\n    async with ExecutionClient(port=container.port) as client:\n        await client.execute(\"\"\"\n            with open('data/input.txt') as f:\n                data = f.read()\n\n            processed = data.upper()\n\n            with open('output/result.txt', 'w') as f:\n                f.write(processed)\n        \"\"\")  # (4)!\n\nasync with aiofiles.open(\"output/result.txt\", \"r\") as f:  # (5)!\n    result = await f.read()\n    assert result == \"HELLO WORLD\"\n</code></pre> <ol> <li>Map host paths to container paths.</li> <li>For reading files from host.</li> <li>For writing files to host.</li> <li>Read from mounted <code>data</code> directory, convert to uppercase and write to mounted <code>output</code> directory</li> <li>Verify the results on host</li> </ol>"},{"location":"usage/#environment-variables","title":"Environment variables","text":"<p>Environment variables can be set on the container for passing secrets or configuration data, for example.</p> <pre><code># Define environment variables for the container\nenv = {\"API_KEY\": \"secret-key-123\", \"DEBUG\": \"1\"}  # (1)!\n\nasync with ExecutionContainer(env=env) as container:\n    async with ExecutionClient(port=container.port) as client:\n        result = await client.execute(\"\"\"\n            import os\n\n            api_key = os.environ['API_KEY']\n            print(f\"Using API key: {api_key}\")\n\n            debug = bool(int(os.environ.get('DEBUG', '0')))\n            if debug:\n                print(\"Debug mode enabled\")\n        \"\"\")  # (2)!\n        print(result.text)  # (3)!\n</code></pre> <ol> <li>Define environment variables for the container</li> <li>Access environment variables in executed code</li> <li>Prints     <pre><code>Using API key: secret-key-123\nDebug mode enabled\n</code></pre></li> </ol>"},{"location":"usage/#manual-container-lifecycle-management","title":"Manual container lifecycle management","text":"<p>Instead of using <code>ExecutionContainer</code> as a context manager, you can also manually <code>run()</code> and <code>kill()</code> the container. This is useful for running the container on a separate host listening to a user-defined host port (e.g. <code>7777</code> in the example below).</p> <pre><code>container = ExecutionContainer(port=7777)  # (1)!\nawait container.run()  # (2)!\nassert container.port == 7777\n\n# do some work ...\n\nawait container.kill()  # (3)!\n</code></pre> <ol> <li>Create an <code>ExecutionContainer</code> instance using a fixed port.</li> <li>Run the container (detached).</li> <li>Cleanup.</li> </ol>"},{"location":"api/execution_client/","title":"ExecutionClient","text":""},{"location":"api/execution_client/#ipybox.executor.ExecutionClient","title":"ExecutionClient","text":"<pre><code>ExecutionClient(port: int, host: str = 'localhost', heartbeat_interval: float = 10)\n</code></pre> <p>A context manager for executing code in an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname where the code execution container is running</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Host port of the code execution container</p> required <code>heartbeat_interval</code> <code>float</code> <p>Interval in seconds between heartbeat pings. Defaults to 10.</p> <code>10</code> Example <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\nbinds = {\"/host/path\": \"example/path\"}\nenv = {\"API_KEY\": \"secret\"}\n\nasync with ExecutionContainer(binds=binds, env=env) as container:\n    async with ExecutionClient(host=\"localhost\", port=container.port) as client:\n        result = await client.execute(\"print('Hello, world!')\")\n        print(result.text)\n</code></pre> <p>Hello, world!</p> Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, port: int, host: str = \"localhost\", heartbeat_interval: float = 10):\n    self.port = port\n    self.host = host\n\n    self._heartbeat_interval = heartbeat_interval\n    self._heartbeat_callback = None\n\n    self._kernel_id = None\n    self._ws: WebSocketClientConnection\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.kernel_id","title":"kernel_id  <code>property</code>","text":"<pre><code>kernel_id\n</code></pre> <p>The ID of the running IPython kernel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not connected to a kernel</p>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(retries: int = 10, retry_interval: float = 1.0)\n</code></pre> <p>Creates and connects to an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>Number of connection attempts. Defaults to 10.</p> <code>10</code> <code>retry_interval</code> <code>float</code> <p>Delay between retries in seconds. Defaults to 1.0.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If connection cannot be established after all retries</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def connect(self, retries: int = 10, retry_interval: float = 1.0):\n    \"\"\"Creates and connects to an IPython kernel.\n\n    Args:\n        retries: Number of connection attempts. Defaults to 10.\n        retry_interval: Delay between retries in seconds. Defaults to 1.0.\n\n    Raises:\n        ConnectionError: If connection cannot be established after all retries\n    \"\"\"\n    for _ in range(retries):\n        try:\n            self._kernel_id = await self._create_kernel()\n            break\n        except Exception:\n            await asyncio.sleep(retry_interval)\n    else:\n        raise ConnectionError(\"Failed to create kernel\")\n\n    self._ws = await websocket_connect(HTTPRequest(url=self.kernel_ws_url))\n    logger.info(\"Connected to kernel\")\n\n    self.heartbeat_callback = PeriodicCallback(self._ping_kernel, self._heartbeat_interval * 1000)\n    self.heartbeat_callback.start()\n    logger.info(f\"Started heartbeat (interval = {self._heartbeat_interval}s)\")\n\n    await self._init_kernel()\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect()\n</code></pre> <p>Closes the connection to the kernel and cleans up resources.</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def disconnect(self):\n    \"\"\"Closes the connection to the kernel and cleans up resources.\"\"\"\n    self.heartbeat_callback.stop()\n    self._ws.close()\n    async with aiohttp.ClientSession() as session:\n        async with session.delete(self.kernel_http_url):\n            pass\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(code: str, timeout: float = 120) -&gt; ExecutionResult\n</code></pre> <p>Executes code and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to execute</p> required <code>timeout</code> <code>float</code> <p>Maximum execution time in seconds. Defaults to 120.</p> <code>120</code> <p>Returns:</p> Type Description <code>ExecutionResult</code> <p>ExecutionResult object</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raised an error</p> <code>TimeoutError</code> <p>If execution exceeds timeout duration</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def execute(self, code: str, timeout: float = 120) -&gt; ExecutionResult:\n    \"\"\"Executes code and returns the result.\n\n    Args:\n        code: Code to execute\n        timeout: Maximum execution time in seconds. Defaults to 120.\n\n    Returns:\n        ExecutionResult object\n\n    Raises:\n        ExecutionError: If code execution raised an error\n        asyncio.TimeoutError: If execution exceeds timeout duration\n    \"\"\"\n    execution = await self.submit(code)\n    return await execution.result(timeout=timeout)\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.submit","title":"submit  <code>async</code>","text":"<pre><code>submit(code: str) -&gt; Execution\n</code></pre> <p>Submits code for execution and returns an Execution object to track it.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute</p> required <p>Returns:</p> Type Description <code>Execution</code> <p>An Execution object to track the submitted code execution</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def submit(self, code: str) -&gt; Execution:\n    \"\"\"Submits code for execution and returns an Execution object to track it.\n\n    Args:\n        code: Python code to execute\n\n    Returns:\n        An Execution object to track the submitted code execution\n    \"\"\"\n    req_id = uuid4().hex\n    req = {\n        \"header\": {\n            \"username\": \"\",\n            \"version\": \"5.0\",\n            \"session\": \"\",\n            \"msg_id\": req_id,\n            \"msg_type\": \"execute_request\",\n        },\n        \"parent_header\": {},\n        \"channel\": \"shell\",\n        \"content\": {\n            \"code\": code,\n            \"silent\": False,\n            \"store_history\": False,\n            \"user_expressions\": {},\n            \"allow_stdin\": False,\n        },\n        \"metadata\": {},\n        \"buffers\": {},\n    }\n\n    await self._send_request(req)\n    return Execution(client=self, req_id=req_id)\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionResult","title":"ExecutionResult  <code>dataclass</code>","text":"<pre><code>ExecutionResult(text: str | None, images: list[Image])\n</code></pre> <p>The result of a code execution.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Output text generated during execution</p> required <code>images</code> <code>list[Image]</code> <p>List of images generated during execution</p> required"},{"location":"api/execution_client/#ipybox.executor.Execution","title":"Execution","text":"<pre><code>Execution(client: ExecutionClient, req_id: str)\n</code></pre> <p>Represents a code execution in an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>ExecutionClient</code> <p>The client instance that created this execution</p> required <code>req_id</code> <code>str</code> <p>Unique identifier for the execution request</p> required Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, client: \"ExecutionClient\", req_id: str):\n    self.client = client\n    self.req_id = req_id\n\n    self._chunks: list[str] = []\n    self._images: list[Image.Image] = []\n\n    self._stream_consumed: bool = False\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.Execution.result","title":"result  <code>async</code>","text":"<pre><code>result(timeout: float = 120) -&gt; ExecutionResult\n</code></pre> <p>Waits for execution to complete and returns the final result.</p> <p>If a timeout is reached, the kernel is interrupted.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds. Defaults to 120.</p> <code>120</code> <p>Returns:</p> Type Description <code>ExecutionResult</code> <p>ExecutionResult object</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If execution exceeds timeout duration</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def result(self, timeout: float = 120) -&gt; ExecutionResult:\n    \"\"\"Waits for execution to complete and returns the final result.\n\n    If a timeout is reached, the kernel is interrupted.\n\n    Args:\n        timeout: Maximum time to wait in seconds. Defaults to 120.\n\n    Returns:\n        ExecutionResult object\n\n    Raises:\n        asyncio.TimeoutError: If execution exceeds timeout duration\n    \"\"\"\n    if not self._stream_consumed:\n        async for _ in self.stream(timeout=timeout):\n            pass\n\n    return ExecutionResult(\n        text=\"\".join(self._chunks).strip() if self._chunks else None,\n        images=self._images,\n    )\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.Execution.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(timeout: float = 120) -&gt; AsyncIterator[str]\n</code></pre> <p>Streams the execution output text as it becomes available.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds. Defaults to 120.</p> <code>120</code> <p>Yields:</p> Type Description <code>AsyncIterator[str]</code> <p>Output text chunks as they arrive</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If execution exceeds timeout duration</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def stream(self, timeout: float = 120) -&gt; AsyncIterator[str]:\n    \"\"\"Streams the execution output text as it becomes available.\n\n    Args:\n        timeout: Maximum time to wait in seconds. Defaults to 120.\n\n    Yields:\n        Output text chunks as they arrive\n\n    Raises:\n        asyncio.TimeoutError: If execution exceeds timeout duration\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async for elem in self._stream():\n                match elem:\n                    case str():\n                        self._chunks.append(elem)\n                        yield elem\n                    case Image.Image():\n                        self._images.append(elem)\n    except asyncio.TimeoutError:\n        await self.client._interrupt_kernel()\n        await asyncio.sleep(0.2)  # TODO: make configurable\n        raise\n    finally:\n        self._stream_consumed = True\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionError","title":"ExecutionError","text":"<pre><code>ExecutionError(message: str, trace: str | None = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raised when code execution in the IPython kernel fails.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>trace</code> <code>str | None</code> <p>Stack trace string representation</p> <code>None</code> Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, message: str, trace: str | None = None):\n    super().__init__(message)\n    self.trace = trace\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when connection to an IPython kernel fails.</p>"},{"location":"api/execution_container/","title":"ExecutionContainer","text":"<p>A context manager for managing the lifecycle of a Docker container used for code execution.</p> <p>It handles the creation, port mapping, volume binding, and cleanup of the container.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag of the Docker image to use (defaults to gradion-ai/ipybox)</p> <code>DEFAULT_TAG</code> <code>binds</code> <code>dict[str, str] | None</code> <p>Mapping of host paths to container paths for volume mounting. Host paths may be relative or absolute. Container paths must be relative and are created as subdirectories of <code>/home/appuser</code> in the container.</p> <code>None</code> <code>env</code> <code>dict[str, str] | None</code> <p>Environment variables to set in the container</p> <code>None</code> <code>port</code> <code>int | None</code> <p>Host port to map to the container's executor port. If not provided, a random port will be allocated.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>Host port mapped to the container's executor port. This port is dynamically allocated when the container is started.</p> Example <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\nbinds = {\"/host/path\": \"example/path\"}\nenv = {\"API_KEY\": \"secret\"}\n\nasync with ExecutionContainer(binds=binds, env=env) as container:\n    async with ExecutionClient(host=\"localhost\", port=container.port) as client:\n        result = await client.execute(\"print('Hello, world!')\")\n        print(result.text)\n</code></pre> <p>Hello, world!</p> Source code in <code>ipybox/container.py</code> <pre><code>def __init__(\n    self,\n    tag: str = DEFAULT_TAG,\n    binds: dict[str, str] | None = None,\n    env: dict[str, str] | None = None,\n    port: int | None = None,\n):\n    self.tag = tag\n    self.binds = binds or {}\n    self.env = env or {}\n\n    self._docker = None\n    self._container = None\n    self._port = port\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.port","title":"port  <code>property</code>","text":"<pre><code>port: int\n</code></pre> <p>The host port mapped to the container's executor port.</p> <p>This port is dynamically allocated when the container is started unless explicitly provided.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container is not running</p>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.kill","title":"kill  <code>async</code>","text":"<pre><code>kill()\n</code></pre> <p>Kill and remove the Docker container.</p> Source code in <code>ipybox/container.py</code> <pre><code>async def kill(self):\n    \"\"\"\n    Kill and remove the Docker container.\n    \"\"\"\n    if self._container:\n        await self._container.kill()\n\n    if self._docker:\n        await self._docker.close()\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Create and start the Docker container.</p> Source code in <code>ipybox/container.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Create and start the Docker container.\n    \"\"\"\n    self._docker = Docker()\n    self._container = await self._run()\n</code></pre>"}]}